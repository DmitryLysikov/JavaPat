Задание 2 Singleton

В приложении To-Do List класс TaskManager реализован с использованием паттерна Singleton.
1. Класс TaskManager является главной частью программы, в котором реализованны, функции взаимодействия с задачами. Для того чтобы обеспечить согласованность и целостность данных во всем приложении, важно, чтобы все операции над задачами выполнялись через один и тот же объект. Использование Singleton здесь гарантирует, что все модули и компоненты приложения обращаются к одному и тому же объекту TaskManager и работают с одними и теми же данными.
2. Мы предотвращаем создание нескольких экземпляров, что могло бы привести к нарушению логики программы. То есть если бы в приложении использовалось несколько экземпляров TaskManager, то каждая часть программы могла бы случайно работать со своим набором задач. Например, если один экземпляр TaskManager добавит задачу, другой экземпляр (если бы он существовал) не будет "знать" об этой задаче.
3. Singleton предоставляет глобальную точку доступа к TaskManager, что позволяет любому компоненту программы (например, классу ToDoApp или любым другим компонентам в будущем) взаимодействовать с задачами без лишней передачи зависимостей.


Задание 3 Prototype

В классе Task реализован паттерн Prototype.
Паттерн реализован в этом классе для того, чтобы обеспечить возможность клонирования объектов Task. Это удобно в тех случаях, когда нужно быстро создавать копии объектов с теми же свойствами, что повышает гибкость и уменьшает затраты на создание новых объектов.

Задание 5 Builder

Класс Task реализован с использованием шаблона проектирования Builder для упрощения создания объектов с большим количеством параметров. Данный подход повышает читаемость и удобство кода, позволяя поэтапно задавать атрибуты задачи, что исключает необходимость в перегруженных конструкторах и повышает гибкость настройки объектов.

Использование шаблона Builder способствует улучшению сопровождаемости кода, облегчает добавление новых параметров и предотвращает ошибки, связанные с порядком передачи аргументов. Кроме того, он гармонично интегрируется с шаблоном Prototype для клонирования объектов, что делает его оптимальным выбором для сложных сущностей, таких как задачи.

Задание 7 Abstract Factory

Паттерн реализован в классе HighPriorityTaskFactory. Потому что использование Abstract Factory позволяет легко добавлять новые типы задач без изменения основного кода приложения. Например, если в будущем появится необходимость в создании новых типов задач с различными свойствами или поведением, можно будет просто добавить новую фабрику, не затрагивая существующий код.Каждая фабрика отвечает за создание конкретного типа задачи. Это соответствует принципу единственной ответственности, что упрощает понимание и тестирование каждой части кода.

Задание 9 Bridge

Основная идея паттерна Bridge — разделить абстракцию и реализацию так, чтобы они могли развиваться независимо друг от друга. В данном случае:

Абстракция: Класс TaskAbstraction, который содержит общие методы для работы с задачами. Его потомок  HighPriorityTask, добавляют конкретное поведение.

Реализация: Интерфейс TaskTypeImplementor и его реализация HighPriorityTaskImplementor, управляют деталями конкретного поведения задач (например, установка приоритета и даты).

Задание 10 Composite

Класс TaskManager реализован как паттерн Composite, потому что он управляет как отдельными задачами (TaskLeaf), так и составными группами задач (TaskComposite). 

Это позволяет обрабатывать задачи и их группы через общий интерфейс, поддерживая иерархическую структуру. Composite предоставляет гибкость для работы с простыми и сложными структурами задач одинаково. Такой подход упрощает управление задачами независимо от их сложности.

Задание 12 Facade

TaskManagerFacade реализован как Facade для предоставления упрощённого интерфейса к функциям управления задачами. 

Этот класс объединяет ключевые операции, такие как добавление, удаление, копирование и отметка выполнения задач, скрывая сложность их реализации и взаимодействия между компонентами. 
Это позволяет клиентскому коду обращаться к системе, не зная о внутренней структуре.

Задание 14 Proxy

Proxy реализован в классе TaskManagerProxy, чтобы добавить контроль доступа, логирование и гибкость к TaskManager. 
TaskManagerProxy позволяет выполнять проверки перед операциями, например, при добавлении или удалении задач, не изменяя основной класс TaskManager.
Это решение снижает зависимость, так как Main взаимодействует с задачами через прокси, что упрощает возможные изменения в будущем.