Задание 2 Singleton

В приложении To-Do List класс TaskManager реализован с использованием паттерна Singleton.
1. Класс TaskManager является главной частью программы, в котором реализованны, функции взаимодействия с задачами. Для того чтобы обеспечить согласованность и целостность данных во всем приложении, важно, чтобы все операции над задачами выполнялись через один и тот же объект. Использование Singleton здесь гарантирует, что все модули и компоненты приложения обращаются к одному и тому же объекту TaskManager и работают с одними и теми же данными.
2. Мы предотвращаем создание нескольких экземпляров, что могло бы привести к нарушению логики программы. То есть если бы в приложении использовалось несколько экземпляров TaskManager, то каждая часть программы могла бы случайно работать со своим набором задач. Например, если один экземпляр TaskManager добавит задачу, другой экземпляр (если бы он существовал) не будет "знать" об этой задаче.
3. Singleton предоставляет глобальную точку доступа к TaskManager, что позволяет любому компоненту программы (например, классу ToDoApp или любым другим компонентам в будущем) взаимодействовать с задачами без лишней передачи зависимостей.


Задание 3 Prototype

В классе Task реализован паттерн Prototype.
Паттерн реализован в этом классе для того, чтобы обеспечить возможность клонирования объектов Task. Это удобно в тех случаях, когда нужно быстро создавать копии объектов с теми же свойствами, что повышает гибкость и уменьшает затраты на создание новых объектов.

Задание 5 Builder

Класс Task реализован с использованием шаблона проектирования Builder для упрощения создания объектов с большим количеством параметров. Данный подход повышает читаемость и удобство кода, позволяя поэтапно задавать атрибуты задачи, что исключает необходимость в перегруженных конструкторах и повышает гибкость настройки объектов.

Использование шаблона Builder способствует улучшению сопровождаемости кода, облегчает добавление новых параметров и предотвращает ошибки, связанные с порядком передачи аргументов. Кроме того, он гармонично интегрируется с шаблоном Prototype для клонирования объектов, что делает его оптимальным выбором для сложных сущностей, таких как задачи.

Задание 7 Abstract Factory

Паттерн реализован в классе HighPriorityTaskFactory. Потому что использование Abstract Factory позволяет легко добавлять новые типы задач без изменения основного кода приложения. Например, если в будущем появится необходимость в создании новых типов задач с различными свойствами или поведением, можно будет просто добавить новую фабрику, не затрагивая существующий код.Каждая фабрика отвечает за создание конкретного типа задачи. Это соответствует принципу единственной ответственности, что упрощает понимание и тестирование каждой части кода.

Задание 9 Bridge

Основная идея паттерна Bridge — разделить абстракцию и реализацию так, чтобы они могли развиваться независимо друг от друга. В данном случае:

Абстракция: Класс TaskAbstraction, который содержит общие методы для работы с задачами. Его потомок  HighPriorityTask, добавляют конкретное поведение.

Реализация: Интерфейс TaskTypeImplementor и его реализация HighPriorityTaskImplementor, управляют деталями конкретного поведения задач (например, установка приоритета и даты).

Задание 10 Composite

Класс TaskManager реализован как паттерн Composite, потому что он управляет как отдельными задачами (TaskLeaf), так и составными группами задач (TaskComposite). 

Это позволяет обрабатывать задачи и их группы через общий интерфейс, поддерживая иерархическую структуру. Composite предоставляет гибкость для работы с простыми и сложными структурами задач одинаково. Такой подход упрощает управление задачами независимо от их сложности.

Задание 12 Facade

TaskManagerFacade реализован как Facade для предоставления упрощённого интерфейса к функциям управления задачами. 

Этот класс объединяет ключевые операции, такие как добавление, удаление, копирование и отметка выполнения задач, скрывая сложность их реализации и взаимодействия между компонентами. 
Это позволяет клиентскому коду обращаться к системе, не зная о внутренней структуре.

Задание 14 Proxy

Proxy реализован в классе TaskManagerProxy, чтобы добавить контроль доступа, логирование и гибкость к TaskManager. 
TaskManagerProxy позволяет выполнять проверки перед операциями, например, при добавлении или удалении задач, не изменяя основной класс TaskManager.
Это решение снижает зависимость, так как Main взаимодействует с задачами через прокси, что упрощает возможные изменения в будущем.

Задача 15

Паттерн Chain of Responsibility реализован в классе Main и в специально созданных классах обработчиков, таких как TaskValidationHandler, TaskPriorityHandler, и TaskCompletionStatusHandler. 
В Main цепочка запускается при добавлении задачи, где каждый обработчик отвечает за отдельный этап проверки: валидацию полей, проверку приоритета и установку статуса выполнения. 
Такая структура позволяет гибко добавлять или изменять этапы обработки задачи без изменений в основном коде Main, улучшая его читаемость и расширяемость.

Задание 16

Паттерн Command реализован в классе AddTaskCommand, а также в других классах, таких как DeleteTaskCommand и MarkTaskAsCompletedCommand. 

Данный шаблон позволяет инкапсулировать операции добавления, удаления и завершения задач в отдельных классах. Каждый класс предоставляет метод execute(), который может быть вызван из основного модуля программы Main.

Такой подход упрощает добавление новых команд, повышает расширяемость системы и облегчает управление задачами.  Main становится независимым от деталей реализации команд, что улучшает гибкость и структуру кода.

Задача 18

Паттерн Iterator реализован в классе TaskListIterator, который предоставляет способ последовательного доступа к задачам без раскрытия их внутренней структуры. 

Интерфейс TaskIterator описывает методы hasNext и next для итерации, а TaskListIterator обрабатывает список задач (List<Task>) и управляет текущей позицией. 

В TaskManagerProxy добавлен метод getIterator, чтобы предоставлять экземпляр итератора. В классе Main появился новый пункт меню, который позволяет итерироваться по задачам, выводя их пошагово. 

Итератор изолирует логику обхода от основной программы, что особенно полезно, если структура задач будет изменяться. 

Задача 19

Паттерн Mediator реализован в классе TaskManagerMediator для управления взаимодействием между компонентами системы. Этот паттерн централизует коммуникацию, избавляя классы от прямой зависимости друг от друга. 

Например, при добавлении, удалении или завершении задачи методы медиатора вызываются для синхронизации данных и логики. 

TaskMediator упрощает расширение системы, так как новые компоненты могут взаимодействовать через него, а не напрямую друг с другом. Это уменьшает связанность между объектами и делает код более структурированным. 

В основном используется для координации работы TaskManager и интерфейса пользователя. 

Задача 20 

Паттерн Memento реализован в классе TaskManagerProxy с помощью методов saveState() и restoreState() для сохранения и восстановления состояния задач. 

Объект состояния инкапсулируется в классе TaskManagerMemento, который хранит список текущих задач. Управление состояниями выполняет класс TaskManagerCaretaker, обеспечивающий хранение и выбор сохранённых "снимков". 

Это позволяет фиксировать текущее состояние задач и восстанавливать его при необходимости, что особенно полезно для отмены изменений или возврата к предыдущему состоянию. 

Реализация помогает сохранить инкапсуляцию и улучшает удобство работы с задачами.